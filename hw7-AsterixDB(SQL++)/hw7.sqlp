-- EXAMPLE CODES
DROP DATAVERSE geo IF EXISTS;
CREATE DATAVERSE geo;
USE geo;
CREATE TYPE worldType AS {auto_id:uuid };
CREATE DATASET world(worldType) PRIMARY KEY auto_id AUTOGENERATED;
LOAD DATASET world USING localfs (("path"="127.0.0.1://C:/Users/yang_/OneDrive - UW/database/hw7-master/hw7-master/data/mondial.adm"),("format"="adm"));

use geo;

SELECT Z.name as province_name, U.name AS city_name
    from world as X, X.mondial.country as Y, Y.province as Z,
        (case when is_array(Z.city)
              then Z.city
              ELSE [Z.city] END) AS U
    WHERE Y.name = 'Hungary';

USE geo;

SELECT Z.name AS province_name, (SELECT cities.name FROM cities) AS cities
  FROM world AS X, X.mondial.country AS Y, Y.province AS Z
   LET cities = (CASE WHEN Z.city IS MISSING
                      THEN []
                      WHEN is_array(Z.city)
                      THEN Z.city
                      ELSE [Z.city] END)
 WHERE Y.name = 'Hungary';


USE geo;
SELECT T.id, sum(T.num_members) AS total_members
FROM (SELECT Y.`-id` AS id, strict_count(arr) AS num_members
        FROM world AS X, X.mondial.organization AS Y,
             (CASE WHEN is_array(Y.members)
                   THEN Y.members
                   ELSE [Y.members] END) AS Z
         LET arr = split(Z.`-country`, ' ')) AS T
GROUP BY T.id;


-- Q1: Retrieve the names of all cities located in Peru, sorted alphabetically.
-- Name your output attribute city. [Result Size: 30 rows of {"city":...}]
USE geo;

select (select value U.name
from X.mondial.country as Y, Y.province as Z,
    (case when is_array(Z.city)
          then Z.city
          else [Z.city] END) U
where Y.name="Peru") as city  --let the outputs show in the same column
from world as X;

-- Q2: For each country return its name, its population, and the number of religions, sorted alphabetically by country.
-- Report 0 religions for countries without religions. Name your output attributes country, population, num_religions.
-- [Result Size:  238 rows of {"num_religions":..., "country":..., "population":...} (order of keys can differ)]
USE geo;

select Y.name, Y.population, (case when is_array(Y.religions) then array_count(Y.religions) else 0 end) as num_religions
from world as X, X.mondial.country as Y
order by Y.name;

-- Q3: For each religion return the number of countries where it occurs; order them in decreasing number of countries.
-- Name your output attributes religion, num_countries.
-- [Result size: 37 of {"religion':..., "num_countries":...} (order of keys can differ)]

USE geo;

-- in case not array
select R.religion, count(*) as num_countries
from (select U.`#text` as religion from world as X, X.mondial.country as Y, (case when is_array(Y.religions) then Y.religions else [Y.religions] end) U) R
group by R.religion;

-- Q4: For each ethnic group, return the number of countries where it occurs,
-- as well as the total population world-wide of that group.
-- Hint: you need to multiply the ethnicity’s percentage with the country’s population.
-- Use the functions float(x) and/or int(x) to convert a string to a float or to an int.
-- Name your output attributes ethnic_group, num_countries, total_population.
-- You can leave your final total_population as a float if you like.
-- [Result Size: 262 of {"ethnic_group":..., "num_countries":..., "total_population":...} (order of keys can differ)]

use geo;

-- in case missing
WITH groups as (select U.`#text` as name, float(U.`-percentage`) * 0.01 * float(Y.population) as number
    from world as X, X.mondial.country as Y, case when  Y.ethnicgroups is missing then [] when is_array(Y.ethnicgroups) then Y.ethnicgroups else [Y.ethnicgroups] end U)
select G.name as ethinic_group, count(*) as num_countries, SUM(G.number) as total_population
from groups as G
group by G.name;

-- Q5: Compute the list of all mountains, their heights, and the countries where they are located.
-- Here you will join the "mountain" collection with the "country" collection, on the country code.
-- You should return a list consisting of the mountain name, its height, the country code, and country name,
-- in descending order of the height. Name your output attributes mountain, height, country_code, country_name.
-- [Result Size: 272 rows of {"mountain":..., "height":..., "country_code":..., "country_name":...} (order of keys can differ)]
-- Hint: Some mountains can be located in more than one country. You need to output them for each country they are located in.

use geo;

-- split ["xx xx xx"]
with c_code as(
    select m.name as mountain, m.height, arr as code
    from world as x, x.mondial.mountain as m
    LET arr = split(m.`-country`, ' ')
    )
-- unnest splitted array to match tuples
select distinct c_code.mountain, c_code.height, c.`-car_code` as country_code, c.name as country_name
from world as x, x.mondial.country as c, c_code unnest c_code.code as cc
where cc=c.`-car_code`
order by float(c_code.height) desc;

/*
Q6:Compute a list of countries with all their mountains.
This is similar to the previous problem, but now you will group the mountains for each country;
return both the mountain name and its height.
Your query should return a list where each element consists of the country code, country name,
and a list of mountain names and heights; order the countries by the number of mountains they contain,
in descending order. Name your output attributes country_code, country_name, mountains.
The attribute mountains should be a list of objects, each with the attributes mountain and height.
[Result Size: 238 rows of {"country_code":..., "country_name":..., "mountains": [{"mountain":..., "height":...}, {"mountain":..., "height":...}, ...]} (order of keys can differ)]
*/

use geo;

-- re-nested output
select c.`-car_code` as country_code, c.name as country_name, u as mountains
from world as x, x.mondial.country as c
let u = (
    select m.name as mountain, m.height
    from  x.mondial.mountain as m, split(m.`-country`, ' ') arr
    where c.`-car_code`=arr
    )
order by array_count(u) DESC;

/*
Q7:Find all countries bordering two or more seas.  Here you need to join the "sea" collection with the "country" collection.
For each country in your list, return its code, its name, and the list of bordering seas,
in decreasing order of the number of seas. Name your output attributes country_code, country_name, seas.
The attribute seas should be a list of objects, each with the attribute sea.
[Result Size: 74 rows of {"country_code":..., "country_name":..., "seas": [{"sea":...}, {"sea":...}, ...]} (order of keys can differ)]
*/

USE geo;

select c.`-car_code` as country_code, c.name as country_name, u as seas
from world as x, x.mondial.country as c
let u = (
    select s.name as sea
    from  x.mondial.sea as s, split(s.`-country`, ' ') arr
    where c.`-car_code`=arr
    )
where array_count(u)>=2
order by array_count(u) DESC;

/*
Q8:Return all landlocked countries.  A country is landlocked if it borders no sea.
For each country in your list, return its code, its name, in decreasing order of the country's area.
Note: this should be an easy query to derive from the previous one. Name your output attributes country_code, country_name, area.
[Result Size: 45 rows of {"country_code":..., "country_name":..., "area":...} (order of keys can differ)]
*/

USE geo;

select c.`-car_code` as country_code, c.name as country_name, c.`-area`
from world as x, x.mondial.country as c
let u = (
    select s.name as sea
    from  x.mondial.sea as s, split(s.`-country`, ' ') arr
    where c.`-car_code`=arr
    )
where array_count(u)=0
order by float(c.`-area`) DESC;

/*
Q9: For this query you should also measure and report the runtime; it may be approximate (warning: it might run for a while).
Find all distinct pairs of countries that share both a mountain and a sea.  Your query should return a list of pairs of country names.
Avoid including a country with itself, like in (France,France), and avoid listing both (France,Korea) and (Korea,France) (not a real answer).
Name your output attributes first_country, second_country. [Result Size: 7 rows of {"first_country":..., "second_country":...}]
*/

/*
just curious test
select m.name as mountain_name, s.name as sea_name, m.`-country` as country code
from world as x, x.mondial.mountain as m, x.mondail.sea as s
where m.`-country`=s.`-country`;
*/

USE geo;

with bigdata as (
    select c.`-car_code` as country_code, c.name as country_name, u as seas, v  as mountains
        from world as x, x.mondial.country as c
        let u = (
            select s.name as sea
            from  x.mondial.sea as s, split(s.`-country`, ' ') arr
            where c.`-car_code`=arr
            ),
            v = (
            select m.name as mountain
            from  x.mondial.mountain as m, split(m.`-country`, ' ') arr2
            where c.`-car_code`=arr2
            )
)
select distinct b1.country_name as first_country, b2.country_name as second_country
from bigdata as b1,bigdata as b2, b1.seas as c1, b2.seas as c2, b1.mountains as d1, b2.mountains as d2
where c1.sea=c2.sea and d1.mountain=d2.mountain and b1.country_code < b2.country_code;

-- Duration of all jobs: 19.894 sec

/*Q10: for Q10-Q12, load extra datasets*/
-- create new dataverse
DROP DATAVERSE geoindex IF EXISTS;
CREATE DATAVERSE geoindex;
USE geoindex;
-- create country dataset
    CREATE TYPE countryType AS OPEN {  --OPEN type may include other attributes unlisted here
        `-car_code`: string,
        `-area`: string,
        population: string
    };
    CREATE DATASET country(countryType)
       PRIMARY KEY `-car_code`;
    CREATE INDEX countryID ON country(`-car_code`) TYPE BTREE;
    LOAD DATASET country USING localfs
        (("path"="127.0.0.1://C:/Users/yang_/OneDrive - UW/database/hw7-master/hw7-master/data/country.adm"),("format"="adm"));

-- create mountain dataset
    CREATE TYPE mountainType AS OPEN {
        auto_id:uuid,
        `-id`: string,
        `-country`: string
    };
    CREATE DATASET mountain(mountainType)
       PRIMARY KEY auto_id AUTOGENERATED;
    CREATE INDEX mountainID ON mountain(`-country`) TYPE KEYWORD;
    LOAD DATASET mountain USING localfs
        (("path"="127.0.0.1://C:/Users/yang_/OneDrive - UW/database/hw7-master/hw7-master/data/mountain.adm"),("format"="adm"));

-- create sea dataset
    CREATE TYPE seaType AS OPEN {
        auto_id:uuid,
        `-id`: string,
        `-country`: string
    };
    CREATE DATASET sea(seaType)
       PRIMARY KEY auto_id AUTOGENERATED;
    CREATE INDEX seaID ON sea(`-country`) TYPE KEYWORD;
    LOAD DATASET sea USING localfs
        (("path"="127.0.0.1://C:/Users/yang_/OneDrive - UW/database/hw7-master/hw7-master/data/sea.adm"),("format"="adm"));

/*
Q11: Re-run the query from 9. (“pairs of countries that share both a mountain and a sea”) on the new dataverse geoindex.
Report the new runtime.  [Result Size: 7 rows of {"first_country":..., "second_country":...}]
*/

USE geoindex;

with bigdata as (
    select c.`-car_code` as country_code, c.name as country_name, u as seas, v  as mountains
        from country as c
        let u = (
            select s.name as sea
            from  sea as s, split(s.`-country`, ' ') arr
            where c.`-car_code`=arr
            ),
            v = (
            select m.name as mountain
            from  mountain as m, split(m.`-country`, ' ') arr2
            where c.`-car_code`=arr2
            )
)
select distinct b1.country_name as first_country, b2.country_name as second_country
from bigdata as b1,bigdata as b2, b1.seas as c1, b2.seas as c2, b1.mountains as d1, b2.mountains as d2
where c1.sea=c2.sea and d1.mountain=d2.mountain and b1.country_code < b2.country_code;

-- Duration of all jobs: 0.605 sec

/*
Q12: Modify the query from 11. to return, for each pair of countries, the list of common mountains, and the list of common seas.
Name your output attributes first_country, second_country, mountain, sea.
[Result Size: 7 rows of {"mountains":[{"mountain":...}, ...], "seas":[{"sea":...}, ...], "first_country":..., "second_country":...}]
*/
USE geoindex;

with bigdata as (
    select c.`-car_code` as country_code, c.name as country_name, u as seas, v  as mountains
        from country as c
        let u = (
            select s.name as sea
            from  sea as s, split(s.`-country`, ' ') arr
            where c.`-car_code`=arr
            ),
            v = (
            select m.name as mountain
            from  mountain as m, split(m.`-country`, ' ') arr2
            where c.`-car_code`=arr2
            )
)
select distinct b1.seas, b1.mountains, b1.country_name as first_country, b2.country_name as second_country
from bigdata as b1,bigdata as b2, b1.seas as c1, b2.seas as c2, b1.mountains as d1, b2.mountains as d2
where c1.sea=c2.sea and d1.mountain=d2.mountain and b1.country_code < b2.country_code;

-- Duration of all jobs: 0.56 sec